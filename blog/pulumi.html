<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8" />
  <meta name="description" content="lol thot leadership" />
  <title>Integration testing your cloud infrastructure with Pulumi and Jest</title>

  <link rel="stylesheet" href="../styles.css">
</head>

<header>
  <nav>
    <ul>
      <li>
        <a href="../index.html">about</a>
      </li>
      <li>
        <a href="index.html">blog</a>
      </li>
      <!-- <li>
        <a>reading</a>
      </li> -->
      <li>
        <a href="https://github.com/immykins">github</a>
      </li>
      <li>
        <a href="https://twitter.com/imogenheapsort">twitter</a>
      </li>
    </ul>
  </nav>
</header>

<body>
  <main>
    <div class="content blog">
      <h1>Integration testing your cloud infrastucture with Pulumi and Jest</h1>
      <p>I've been hacking on a cool personal project lately (a queer dating app) and I've architected it to be
        serverless
        using AWS
        Lambda. Instead of manually setting up AWS infrastructure I'm doing everything with <a
          href="https://www.pulumi.com/">Pulumi</a>, an
        infrastructure-as-code cloud management tool.</p>
      <p>The mobile app itself is being written in React Native and uses Jest for testing. I wanted to
        to use Jest for all of my application testing so I could
        keep everything in a single repo with a single test runner, and thankfully Pulumi exposes an automation API that
        can be used for
        integration testing.</p>
      <pre><code>
automation.ts

import {
  LocalProgramArgs,
  LocalWorkspace,
  OutputMap
} from "@pulumi/pulumi/automation";
import * as upath from "upath";

// my pulumi deployment config file
const args: LocalProgramArgs = {
  stackName: "test",
  workDir: upath.joinSafe(__dirname, "..", "..", "pulumi"),
};

export async function deploy(): Promise<OutputMap> {
  console.log("Initialising stack...");
  const stack = await LocalWorkspace.createOrSelectStack(args);

  console.log("Setting region...");
  await stack.setConfig("aws:region", { value: "us-west-1" });

  console.log("Run update...");
  const up = await stack.up({ onOutput: console.log });

  return up.outputs;
}

export async function destroy() {
  console.log("Selecting stack...");
  const stack = await LocalWorkspace.createOrSelectStack(args);

  console.log("Destroying stack...");
  await stack.destroy({ onOutput: console.log });
}

export async function getOutputs(): Promise<OutputMap> {
  const stack = await LocalWorkspace.createOrSelectStack(args);

  var outputs = stack.outputs();

  return outputs;
}

export default { deploy, getOutputs, destroy };
      </code></pre>
      <p>Here you can see a test for an AWS Cognito User Pool. `src/cognito` is a wrapper around Amazon's
        `amazon-cognito-identity-js` node package - I'm using it to create a cognito user over their API. The key part
        is that I'm using automation.getOutputs and using the user pool config values to connect to it via API.</p>
      <pre>
        <code>
cognito.test.ts

import { CognitoUserPool } from '../../src/cognito';
import automation from './automation';

beforeAll(() => {
  return automation.deploy();
});

afterAll(() => {
  return automation.destroy();
});

// just return a promise and jest will wait for it to resolve
test('create a user pool and user', () => {
  const phoneNumber = '+12025550195';

  return automation
    .getOuputs()
    .then((result) => {
      return new CognitoUserPool(
        {
          ClientId: result.clientID.value,
          UserPoolId: result.poolID.value
        }
      );
    })
    .then((pool) => {
      return pool.createUser(phoneNumber);
    })
    .then((result) => {
      expect(result.getUsername()).toBe(phoneNumber);
    });
});
        </code>
      </pre>

      <p>The default timeout for Jest tests is five seconds, which isn't nearly enough to finish spinning up and
        destroying infrastructure. Mine takes about thirty seconds so I've updated the timeout to a minute.</p>
      <pre>
        <code>
package.json

"jest": {
  "testTimeout": 60000
},
        </code>
      </pre>
      <p>The downside to this approach to testing is that it's slow - spinning up and tearing down infrastructure, in
        the simplest of cases, can take well over a minute. Tag these tests and only run them before a deployment - they
        can easily be baked into a
        CI/CD
        system and gate automated deployments.</p>
      <p>In all honesty, I'm considering splitting out my infrastructure code into a separate repo and rewriting the
        pulumi config (and testing) in Go. Not only
        is Go the de-facto
        <em>lingua franca</em> of cloud infrastructure but it also
        supports Pulumi's <a href="https://www.pulumi.com/docs/guides/testing/integration/">integration testing
          framework</a>.
      </p>
      <p><a href="index.html">>> more articles</a></p>
    </div>
  </main>
</body>